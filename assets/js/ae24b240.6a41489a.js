"use strict";(self.webpackChunkopenbrush=self.webpackChunkopenbrush||[]).push([[978],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function l(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var s=a.createContext({}),u=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},p=function(t){var e=u(t.components);return a.createElement(s.Provider,{value:e},t.children)},c="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,s=t.parentName,p=l(t,["components","mdxType","originalType","parentName"]),c=u(n),d=r,h=c["".concat(s,".").concat(d)]||c[d]||m[d]||o;return n?a.createElement(h,i(i({ref:e},p),{},{components:n})):a.createElement(h,i({ref:e},p))}));function h(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=t,l[c]="string"==typeof t?t:r,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3551:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:1,slug:"/smart-contract-openbrush",title:"Creating smart contract using OpenBrush",sidebar_label:"Creating smart contract using OpenBrush"},i="Create your first smart contract using OpenBrush",l={unversionedId:"smart-contract-openbrush",id:"smart-contract-openbrush",title:"Creating smart contract using OpenBrush",description:"In this tutorial, we will explain how to create your first dApp using OpenBrush.",source:"@site/tutorials/smart-contract-openbrush.md",sourceDirName:".",slug:"/smart-contract-openbrush",permalink:"/tutorials/smart-contract-openbrush",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,slug:"/smart-contract-openbrush",title:"Creating smart contract using OpenBrush",sidebar_label:"Creating smart contract using OpenBrush"},sidebar:"tutorialSidebar",next:{title:"Transpiling solidity smart contract with Sol2ink",permalink:"/tutorials/from-solidity-to-ink"}},s={},u=[{value:"Contract\u2019s base",id:"contracts-base",level:2},{value:"Import OpenBrush",id:"import-openbrush",level:2},{value:"Import PSP22 and Ownable",id:"import-psp22-and-ownable",level:2},{value:"Customization",id:"customization",level:2},{value:"Tests",id:"tests",level:2},{value:"Deployment",id:"deployment",level:2}],p={toc:u},c="wrapper";function m(t){let{components:e,...n}=t;return(0,r.kt)(c,(0,a.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"create-your-first-smart-contract-using-openbrush"},"Create your first smart contract using OpenBrush"),(0,r.kt)("p",null,"In this tutorial, we will explain how to create your first dApp using OpenBrush."),(0,r.kt)("p",null,"As a base, we will take a few implementations from OpenBrush: ",(0,r.kt)("a",{parentName:"p",href:"/docs/OpenBrush/smart-contracts/PSP22"},"PSP22"),",\n",(0,r.kt)("a",{parentName:"p",href:"/docs/OpenBrush/smart-contracts/PSP22/Extensions/metadata"},"PSP22Metadata")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/OpenBrush/smart-contracts/ownable"},"Ownable")," extensions."),(0,r.kt)("p",null,"So, let\u2019s start!"),(0,r.kt)("h2",{id:"contracts-base"},"Contract\u2019s base"),(0,r.kt)("p",null,"First of all, we will create a base for our future contract. Every contract needs to have a module marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"#[ink::contract]"),", struct marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"#[ink(storage)]"),", constructor (\n",(0,r.kt)("inlineCode",{parentName:"p"},"#[ink(constructor)]"),") and at least one message (",(0,r.kt)("inlineCode",{parentName:"p"},"#[ink(message)]"),").\nSo, first, let\u2019s take a basic smart contract implementation from ink!:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std, no_main)]\n\n#[ink::contract]\npub mod my_contract {\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Contract {}\n\n    impl Contract { \n        #[ink(constructor)]\n        pub fn new() -> Self {\n          Default::default()\n        }\n\n        #[ink(message)]\n        pub fn get_true(&self) -> bool {\n          true\n        }\n    }\n}\n')),(0,r.kt)("p",null,"Here we have an empty contract\u2019s storage, constructor and a message, that will just return true every time you call it."),(0,r.kt)("p",null,"Pretty simple for now, right?"),(0,r.kt)("h2",{id:"import-openbrush"},"Import OpenBrush"),(0,r.kt)("p",null,"Here we will have two steps: adding the OpenBrush dependency to ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," of your contract and injecting it into your contract\u2019s code.\nSo, to add a dependency, you need to check the latest version of OpenBrush that is compatible with your version of ink!\nAt the time this tutorial is written, the latest release is ",(0,r.kt)("inlineCode",{parentName:"p"},"3.1.0")," and the latest version of ink! is ",(0,r.kt)("inlineCode",{parentName:"p"},"4.2.0"),"."),(0,r.kt)("p",null,"Let\u2019s get to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),", all you need to do is to add a line like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'openbrush = { tag = "3.1.0", git = "https://github.com/Brushfam/openbrush-contracts", default-features = false }\n')),(0,r.kt)("p",null,"And that\u2019s it! Now you have OpenBrush version ",(0,r.kt)("inlineCode",{parentName:"p"},"3.1.0")," imported.\nNow, we want to have it injected in contract\u2019s code.\nIn general, it will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std, no_main)]\n#![feature(min_specialization)]\n\n#[openbrush::contract]\npub mod my_contract {\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Contract {}\n\n    impl Contract { \n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Default::default()\n        }\n\n        #[ink(message)]\n        pub fn get_true(&self) -> bool {\n          true\n        }\n    }\n}\n')),(0,r.kt)("p",null,"As you may notice, we added line ",(0,r.kt)("inlineCode",{parentName:"p"},"#![feature(min_specialization)]"),", which allows you to use OpenBrush default implementations,\nbut this feature is unstable, so you will need to run everything with nightly toolchain. Another thing that is different\nfrom default ink! contract is ",(0,r.kt)("inlineCode",{parentName:"p"},"#[openbrush::contract]")," macro. It allows you to work with OpenBrush traits as they are just Rust traits, which is not true for ink! traits for now."),(0,r.kt)("h2",{id:"import-psp22-and-ownable"},"Import PSP22 and Ownable"),(0,r.kt)("p",null,"To use OpenBrush default implementations, you need to import features in your ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'openbrush = { tag = "3.1.0", git = "https://github.com/Brushfam/openbrush-contracts", default-features = false, features = ["psp22", "ownable"] }\n')),(0,r.kt)("p",null,"Now, the code of your contract with already working PSP22, PSP22 Metadata and Ownable will look:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n#![feature(min_specialization)]\n\n#[openbrush::contract]\npub mod my_contract {\n    use openbrush::{\n        contracts::{ownable::*, psp22::extensions::metadata::*},\n        traits::{DefaultEnv, Storage, String},\n    };\n\n    #[ink(storage)]\n    #[derive(Storage, Default)]\n    pub struct Contract {\n        #[storage_field]\n        psp22: psp22::Data,\n        #[storage_field]\n        metadata: metadata::Data,\n        #[storage_field]\n        ownable: ownable::Data,\n    }\n\n    impl PSP22 for Contract {}\n\n    impl PSP22Metadata for Contract {}\n\n    impl Ownable for Contract {}\n\n    impl Contract {\n        #[ink(constructor)]\n        pub fn new(\n            total_supply: Balance,\n            name: Option<String>,\n            symbol: Option<String>,\n            decimals: u8,\n        ) -> Self {\n            let mut instance: Self = Default::default();\n\n            instance\n                ._mint_to(Self::env().caller(), total_supply)\n                .expect("Should mint");\n\n            instance._init_with_owner(Self::env().caller());\n\n            instance.metadata.name = name;\n            instance.metadata.symbol = symbol;\n            instance.metadata.decimals = decimals;\n\n            instance\n        }\n    }\n}\n')),(0,r.kt)("p",null,"So what changed? Let\u2019s see."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We added imports of required features:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use openbrush::{\ncontracts::{ownable::*, psp22::extensions::metadata::*},\ntraits::{DefaultEnv, Storage, String},\n};\n")),"  ",(0,r.kt)("inlineCode",{parentName:"li"},"ownable::*")," imports required traits and data structs for ownable feature, and ",(0,r.kt)("inlineCode",{parentName:"li"},"psp22::extensions::metadata")," imports both metadata extension and basic PSP22 data.\nOther imports are required for a bit other purposes.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Update the storage struct with the required data:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\n#[derive(Storage)]\npub struct Contract {\n    #[storage_field]\n    psp22: psp22::Data,\n    #[storage_field]\n    metadata: metadata::Data,\n    #[storage_field]\n    ownable: ownable::Data,\n}\n")),(0,r.kt)("p",null,"You can see, that we have added derive for Storage trait. It allows OpenBrush to work with all the data you imported\ninside OpenBrush implementations. We also marked every such field as ",(0,r.kt)("inlineCode",{parentName:"p"},"#[storage_field]"),". It will generate\nimplementation of Storage trait for storage and every marked field, so you will be able to access data like\n",(0,r.kt)("inlineCode",{parentName:"p"},"self.data::<psp22::Data>()")," and it will actually return the required field with data you want."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add impl sections for default trait implementations:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl PSP22 for Contract {}\n\nimpl PSP22Metadata for Contract {}\n\nimpl Ownable for Contract {}\n")),(0,r.kt)("p",{parentName:"li"}," In this section you implement default implementations of these traits. You can also customize them, but we will explain this later.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Update constructor:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[ink(constructor)]\npub fn new(\n    total_supply: Balance,\n    name: Option<String>,\n    symbol: Option<String>,\n    decimals: u8,\n  ) -> Self {\n    let mut instance: Self = Default::default();\n\n    instance\n        ._mint_to(Self::env().caller(), total_supply)\n        .expect("Should mint");\n\n    instance._init_with_owner(Self::env().caller());\n\n    instance.metadata.name = name;\n    instance.metadata.symbol = symbol;\n    instance.metadata.decimals = decimals;\n\n    instance\n} \n')))),(0,r.kt)("p",null,"Here we updated constructor to initialize all the required data for PSP22, PSP22Metadata and Ownable. In some traits\nthere already exists default internal initialize function, like ",(0,r.kt)("inlineCode",{parentName:"p"},"_init_with_owner()"),", but for metadata extension you need to do it manually."),(0,r.kt)("p",null,"So, now you have your basic smart contract, that implements PSP22, PSP22Metadata and Ownable. Let\u2019s customize it!"),(0,r.kt)("h2",{id:"customization"},"Customization"),(0,r.kt)("p",null,"In this section we will show you how you can customize your contract!\nYou can customize any method in OpenBrush default implementation. It is as simple as that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl psp22::Internal for Contract {\n  fn _allowance(&self, owner: &AccountId, spender: &AccountId) -> Balance {\n    self.data::<psp22::Data>()\n      .allowances\n      .get(&(owner, spender))\n      .unwrap_or(10)\n  }\n}\n")),(0,r.kt)("p",null,"So, now method ",(0,r.kt)("inlineCode",{parentName:"p"},"allowance")," will be overridden with your implementation, while all other methods will remain the same.\nIt is better to override ",(0,r.kt)("inlineCode",{parentName:"p"},"Internal")," traits since all the main traits use them, and it is better to divide such functionality.\nSo, ",(0,r.kt)("inlineCode",{parentName:"p"},"allowance")," method from PSP22 is just simply calling ",(0,r.kt)("inlineCode",{parentName:"p"},"_allowance")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"psp22::Internal"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),": This is a raw reimplementation, and it is not saying the truth. So consider it as an example and not the way to do it."),(0,r.kt)("p",null,"Also, we are not use Ownable for now, so let\u2019s create a method that will use it.\nIn your ",(0,r.kt)("inlineCode",{parentName:"p"},"impl Contract")," section add the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(message)]\n#[modifiers(only_owner)]\npub fn mint(&mut self, to: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n    self._mint_to(to, amount)\n}\n")),(0,r.kt)("p",null,"Here we added the ",(0,r.kt)("inlineCode",{parentName:"p"},"mint")," method, that can be only called by the owner of the contract. It can be also implemented as a\npart of PSP22Mintable, but we want to show you how to add custom functionality to your contract by yourself."),(0,r.kt)("p",null,"Now you have your own contract with customized functionality. Let\u2019s go to the next section, where we will be testing it."),(0,r.kt)("h2",{id:"tests"},"Tests"),(0,r.kt)("p",null,"So, in ink! there are two different types of testing: unit tests and integration. In this tutorial we will describe only\nhow to do the unit testing, integration tests are done using ink_e2e testing framework, so for now you can look for\nexamples ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/tree/master/integration-tests"},"here"),"."),(0,r.kt)("p",null,"First of all, inside your contract\u2019s module you need to create a new one \ud83d\ude42."),(0,r.kt)("p",null,"Just like that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(test)]\nmod tests {\n    use super::*;\n}\n")),(0,r.kt)("p",null,"Let\u2019s add a simple test, that will check if ",(0,r.kt)("inlineCode",{parentName:"p"},"total_supply")," works correctly."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg(test)]\nmod tests {\n        use super::*;\n\n    #[ink::test]\n    fn total_supply_works() {\n        // Constructor works.\n          let contract = Contract::new(\n              100,\n            Some(String::from("MyToken")),\n            Some(String::from("MTK")),\n            18,\n        );\n        // Get the token total supply.\n        assert_eq!(contract.total_supply(), 100);\n      }\n}\n')),(0,r.kt)("p",null,"Here we created a new instance of contract and minted 100 tokens. To check if everything works correctly, just run\n",(0,r.kt)("inlineCode",{parentName:"p"},"cargo test")," command."),(0,r.kt)("h2",{id:"deployment"},"Deployment"),(0,r.kt)("p",null,"I guess now you would like to interact with your contract somehow. To do this, let\u2019s run a ",(0,r.kt)("a",{parentName:"p",href:"/docs/substrate-contracts-node"},"substrate node")," and deploy contract there. "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Install contracts-node from ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate-contracts-node"},"here"),". You will also find the instruction to run it if you check the link, but shortly, you can just run the following command: ",(0,r.kt)("inlineCode",{parentName:"p"},"substrate-contracts-node --dev")," ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Build your contract. Run ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo contract build --release")," command and wait until everything will be built.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Open ",(0,r.kt)("a",{parentName:"p",href:"https://contracts-ui.substrate.io/"},"contracts UI")," and click on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Add New Contract")," button and ",(0,r.kt)("inlineCode",{parentName:"p"},"Upload New Contract Code")," then.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Open ",(0,r.kt)("inlineCode",{parentName:"p"},"target")," directory that was generated when you built your contract. You should see ink directory there, open it and\ndrag file called ",(0,r.kt)("inlineCode",{parentName:"p"},"your_contract_name.contract")," to the UI (your_contract_name is just an example\ud83d\ude03, it will be called the same name as your cargo project). ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"After that you can click next and see the window, where you can provide initial parameters to constructor of your contract.\nAfter doing that, just click ",(0,r.kt)("inlineCode",{parentName:"p"},"Upload and Instantiate")," button and that\u2019s it! You can interact with your contract on-chain."))))}m.isMDXComponent=!0}}]);