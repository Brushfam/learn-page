"use strict";(self.webpackChunkopenbrush=self.webpackChunkopenbrush||[]).push([[4525],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>k});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},s=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),u=p(t),m=o,k=u["".concat(l,".").concat(m)]||u[m]||d[m]||r;return t?a.createElement(k,c(c({ref:n},s),{},{components:t})):a.createElement(k,c({ref:n},s))}));function k(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,c=new Array(r);c[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[u]="string"==typeof e?e:o,c[1]=i;for(var p=2;p<r;p++)c[p]=t[p];return a.createElement.apply(null,c)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1417:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>p});var a=t(7462),o=(t(7294),t(3905));const r={sidebar_position:1,slug:"/Typechain",title:"Typechain Documentation",sidebar_label:"How to use"},c="Typechain Documentation",i={unversionedId:"Typechain/overview",id:"Typechain/overview",title:"Typechain Documentation",description:"Packages of Typechain-Polkadot",source:"@site/docs/Typechain/overview.md",sourceDirName:"Typechain",slug:"/Typechain",permalink:"/docs/Typechain",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,slug:"/Typechain",title:"Typechain Documentation",sidebar_label:"How to use"},sidebar:"tutorialSidebar",previous:{title:"Known issues",permalink:"/docs/Sol2ink/issues"},next:{title:"Overview",permalink:"/docs/Typechain/typechain-polkadot/overview"}},l={},p=[{value:"Packages of Typechain-Polkadot",id:"packages-of-typechain-polkadot",level:2},{value:"How to use Typechain-Polkadot",id:"how-to-use-typechain-polkadot",level:2},{value:"Typechain-Compiler case",id:"typechain-compiler-case",level:3},{value:"Events",id:"events",level:3},{value:"How to use it directly via <code>typechain-polkadot</code>?",id:"how-to-use-it-directly-via-typechain-polkadot",level:2}],s={toc:p},u="wrapper";function d(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,a.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"typechain-documentation"},"Typechain Documentation"),(0,o.kt)("h2",{id:"packages-of-typechain-polkadot"},"Packages of Typechain-Polkadot"),(0,o.kt)("p",null,"Typechain Polkadot has 4 main packages:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"typechain-polkadot")," - main package, which contains all logic for generating interfaces for contracts"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"typechain-polkadot-parser")," - package for parsing types of contracts received from metadata"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"typechain-compiler")," - package that allows you to run typechain easily on the big projects, it automatically compiles all contracts and generates typechain-code for them."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"typechain-types")," - package that contains types for typechain-polkadot, that are used in generated code.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"how-to-use-typechain-polkadot"},"How to use Typechain-Polkadot"),(0,o.kt)("p",null,"If you want to use Typechain-Polkadot, you have few options:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"You can use ",(0,o.kt)("inlineCode",{parentName:"li"},"typechain-compiler")," package, which allows you to run typechain easily on the big projects, it automatically compiles all contracts and generates typechain-code for them."),(0,o.kt)("li",{parentName:"ul"},"You can use ",(0,o.kt)("inlineCode",{parentName:"li"},"typechain-polkadot")," package, which contains all logic for generating interfaces for contracts. You can use it as a library or as a CLI tool.")),(0,o.kt)("h3",{id:"typechain-compiler-case"},"Typechain-Compiler case"),(0,o.kt)("p",null,"As was mentioned above, ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain-compiler")," package allows you to run typechain easily on the big projects, it automatically compiles all contracts and generates typechain-code for them.\nSo let's create a simple project, which will contain 2 contracts, and we will use ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain-compiler")," to generate typechain-code for them."),(0,o.kt)("p",null,"1) First of all, let's create a project:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ mkdir typechain-compiler-example\n$ cd typechain-compiler-example\n$ npm init -y\n")),(0,o.kt)("p",null,"And add typescript config:\n",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "compilerOptions": {\n    "target": "es2016",\n    "module": "commonjs",\n    "resolveJsonModule": true,\n    "esModuleInterop": true,\n    "forceConsistentCasingInFileNames": true,\n    "strict": true,\n    "skipLibCheck": true\n  }\n}\n')),(0,o.kt)("p",null,"2) Now, let's create directory for contracts:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ mkdir contracts\n")),(0,o.kt)("p",null,"3) Let's create 2 contracts, which will be used in our example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ cd contracts\n$ cargo contract new flipper\n$ cargo contract new psp22\n")),(0,o.kt)("p",null,"4) Let's let flipper be flipper, and add some code to psp22. For this, let's copy code from openbrush wizard:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'# psp22/Cargo.toml\n[package]\nname = "my_psp22"\nversion = "1.0.0"\nedition = "2021"\nauthors = ["The best developer ever"]\n\n[dependencies]\n\nink = { git = "https://github.com/paritytech/ink", rev = "4655a8b4413cb50cbc38d1b7c173ad426ab06cde", default-features = false }\n\nscale = { package = "parity-scale-codec", version = "3", default-features = false, features = ["derive"] }\nscale-info = { version = "2.3", default-features = false, features = ["derive"], optional = true }\n\n# Include brush as a dependency and enable default implementation for PSP22 via brush feature\nopenbrush = { tag = "3.0.0-beta", git = "https://github.com/727-Ventures/openbrush-contracts", default-features = false, features = ["psp22"] }\n\n[lib]\nname = "my_psp22"\npath = "lib.rs"\ncrate-type = [\n    # Used for normal contract Wasm blobs.\n    "cdylib",\n]\n\n[features]\ndefault = ["std"]\nstd = [\n    "ink/std",\n    "scale/std",\n    "scale-info/std",\n\n    "openbrush/std",\n]\nink-as-dependency = []\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// psp22/lib.rs\n#![cfg_attr(not(feature = "std"), no_std)]\n#![feature(min_specialization)]\n\n#[openbrush::contract]\npub mod my_psp22 {\n\n    // imports from openbrush\n    use openbrush::contracts::psp22::*;\n    use openbrush::traits::Storage;\n\n    #[ink(storage)]\n    #[derive(Default, Storage)]\n    pub struct Contract {\n        #[storage_field]\n        psp22: psp22::Data,\n    }\n\n    // Section contains default implementation without any modifications\n    impl PSP22 for Contract {}\n\n    impl Contract {\n        #[ink(constructor)]\n        pub fn new(initial_supply: Balance) -> Self {\n            let mut _instance = Self::default();\n            _instance._mint_to(_instance.env().caller(), initial_supply).expect("Should mint");\n            _instance\n        }\n    }\n}\n')),(0,o.kt)("p",null,"Alright, now we have 2 contracts, let's create a file, which will contain our configuration for ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain-compiler"),":"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"You should be on the root of your project"),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ touch typechain.config.json\n"))),(0,o.kt)("p",null,"5) Let's add some configuration to our ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain.config.json"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "projectFiles": ["./contracts/**"],\n  "artifactsPath": "./artifacts",\n  "typechainGeneratedPath": "./typechain-generated"\n}\n')),(0,o.kt)("p",null,"To dive deeper into configuration, you can check ",(0,o.kt)("a",{parentName:"p",href:"/docs/Typechain/typechain-compiler"},"typechain-compiler documentation")),(0,o.kt)("p",null,"6) And now, let's install ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain-compiler"),". Also we will need to have ",(0,o.kt)("inlineCode",{parentName:"p"},"@polkadot/api"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"@polkadot/api-contract")," and some other packages installed:\nAdd the following to your ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'"dependencies": {\n    "@727-ventures/typechain-compiler": "^0.5.16",\n    "@727-ventures/typechain-types": "^0.0.22",\n    "@types/node": "^17.0.34",\n    "ts-node": "^10.7.0",\n    "typescript": "^4.6.4",\n    "@polkadot/api": "^9.13.4",\n    "@polkadot/api-contract": "^9.13.4",\n    "@polkadot/keyring": "^10.4.2",\n    "@types/bn.js": "^5.1.0"\n}\n')),(0,o.kt)("p",null,"And install it with ",(0,o.kt)("inlineCode",{parentName:"p"},"npm install"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"If you're still confused, you can check our examples in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/727-Ventures/typechain-polkadot/tree/master/examples"},"examples")," directory")),(0,o.kt)("p",null,"7) Now, let's run ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain-compiler"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ npx @727-ventures/typechain-compiler --config typechain.config.json\n")),(0,o.kt)("p",null,"8) And now, you can use generated code in your project. For example, you can create a file ",(0,o.kt)("inlineCode",{parentName:"p"},"index.ts"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"// In this example we will deploy & interact with psp22 token to transfer some tokens to the owner and get total supply.\nimport {ApiPromise, Keyring} from \"@polkadot/api\";\nimport Constructors from \"./typechain-generated/constructors/my_psp22\";\nimport Contract from \"./typechain-generated/contracts/my_psp22\";\n\nasync function main() {\n    // Connect to the local node\n    const api = await ApiPromise.create();\n\n    // Create keyring pair for Alice and Bob\n    const keyring = new Keyring({type: 'sr25519'});\n\n    const aliceKeyringPair = keyring.addFromUri('//Alice');\n    const bobKeyringPair = keyring.addFromUri('//Bob');\n\n    // Create instance of constructors, that will be used to deploy contracts\n    // Constructors contains all constructors from the contract\n    const constructors = new Constructors(api, aliceKeyringPair);\n\n    // Deploy contract via constructor\n    const {address: TOKEN_ADDRESS} = await constructors.new(10000);\n\n    console.log('Contract deployed at:', TOKEN_ADDRESS);\n\n    const contract = new Contract(TOKEN_ADDRESS, aliceKeyringPair, api);\n\n    const totalSupply = await contract.query.totalSupply();\n    const balance = await contract.query.balanceOf(aliceKeyringPair.address);\n\n    console.log(`%c Total supply before transfer: ${totalSupply.value.unwrap().toNumber()}`, 'color: green');\n    console.log(`%c Balance of Alice before transfer: ${balance.value.unwrap()}`, 'color: green');\n\n    const mintTx = await contract.tx.transfer(bobKeyringPair.address, 1, []);\n\n    const totalSupplyAfterMint = await contract.query.totalSupply();\n    const balanceAfterMint = await contract.query.balanceOf(aliceKeyringPair.address);\n\n    console.log(`%c Total supply after transfer: ${totalSupplyAfterMint.value.unwrap().toNumber()}`, 'color: green');\n    console.log(`%c Balance of Alice after transfer: ${balanceAfterMint.value.unwrap()}`, 'color: green');\n\n    await api.disconnect();\n}\n\nmain().then(() => {\n    console.log('done');\n});\n")),(0,o.kt)("p",null,"9) To interact with our contract, we need to have ",(0,o.kt)("inlineCode",{parentName:"p"},"substrate-contracts-node")," installed and running:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/paritytech/substrate-contracts-node\ncd ./substrate-contracts-node\ngit checkout v0.23.0\ncargo +stable build --release\n./target/release/substrate-contracts-node --dev --tmp\n")),(0,o.kt)("p",null,"10) And now, you can run it with ",(0,o.kt)("inlineCode",{parentName:"p"},"ts-node"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ npx ts-node index.ts\n")),(0,o.kt)("p",null,"Whoa! We've just deployed and interacted with our contract! \ud83c\udf89"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Link to the full example: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/varex83/typechain-compiler-example/tree/main"},"typechain-compiler-example"))),(0,o.kt)("h3",{id:"events"},"Events"),(0,o.kt)("p",null,"In this section we will handle smart contract events!"),(0,o.kt)("p",null,"1) Let's add ",(0,o.kt)("inlineCode",{parentName:"p"},"event")," to our contract, so the final code will look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n#![feature(min_specialization)]\n\n#[openbrush::contract]\npub mod my_psp22 {\n\n    // imports from openbrush\n    use openbrush::contracts::psp22::*;\n    use openbrush::traits::{DefaultEnv, Storage};\n    use ink::codegen::EmitEvent;\n\n    #[ink(storage)]\n    #[derive(Default, Storage)]\n    pub struct Contract {\n        #[storage_field]\n        psp22: psp22::Data,\n    }\n\n    #[ink(event)]\n    pub struct TransferEvent {\n        #[ink(topic)]\n        from: Option<AccountId>,\n        #[ink(topic)]\n        to: Option<AccountId>,\n        value: Balance,\n    }\n\n    // Section contains default implementation without any modifications\n    impl PSP22 for Contract {}\n\n    impl Transfer for Contract {\n        fn _after_token_transfer(&mut self, _from: Option<&AccountId>, _to: Option<&AccountId>, _amount: &Balance) -> Result<(), PSP22Error> {\n            Self::env().emit_event(TransferEvent { from: _from.copied(), to: _to.copied(), value: *_amount });\n            Ok(())\n        }\n    }\n\n    impl Contract {\n        #[ink(constructor)]\n        pub fn new(initial_supply: Balance) -> Self {\n            let mut _instance = Self::default();\n            _instance._mint_to(_instance.env().caller(), initial_supply).expect("Should mint");\n            _instance\n        }\n    }\n}\n')),(0,o.kt)("p",null,"2) And now, let's run ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain-compiler")," in the root of our project:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ npx @727-Ventures/typechain-compiler --config typechain.config.json\n")),(0,o.kt)("p",null,"3) And now, let's add subscription to the events, so the final code will look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"// index.ts\n// In this example we will deploy & interact with psp22 token to mint some tokens to the owner and get total supply.\nimport {ApiPromise, Keyring} from \"@polkadot/api\";\nimport Constructors from \"./typechain-generated/constructors/my_psp22\";\nimport Contract from \"./typechain-generated/contracts/my_psp22\";\n\nasync function main() {\n    const api = await ApiPromise.create();\n\n    const keyring = new Keyring({type: 'sr25519'});\n\n    const aliceKeyringPair = keyring.addFromUri('//Alice');\n    const bobKeyringPair = keyring.addFromUri('//Bob');\n\n    const constructors = new Constructors(api, aliceKeyringPair);\n\n    const {address: TOKEN_ADDRESS} = await constructors.new(10000);\n\n    console.log('Contract deployed at:', TOKEN_ADDRESS);\n\n    const contract = new Contract(TOKEN_ADDRESS, aliceKeyringPair, api);\n\n    const totalSupply = await contract.query.totalSupply();\n    const balance = await contract.query.balanceOf(aliceKeyringPair.address);\n\n    console.log(`%c Total supply before transfer: ${totalSupply.value.unwrap().toNumber()}`, 'color: green');\n    console.log(`%c Balance of Alice before transfer: ${balance.value.unwrap()}`, 'color: green');\n\n    contract.events.subscribeOnTransferEventEvent((event) => {\n        console.log('Transfer event received:', event);\n    });\n\n    const mintTx = await contract.tx.transfer(bobKeyringPair.address, 1, []);\n\n    const totalSupplyAfterMint = await contract.query.totalSupply();\n    const balanceAfterMint = await contract.query.balanceOf(aliceKeyringPair.address);\n\n    console.log(`%c Total supply after transfer: ${totalSupplyAfterMint.value.unwrap().toNumber()}`, 'color: green');\n    console.log(`%c Balance of Alice after transfer: ${balanceAfterMint.value.unwrap()}`, 'color: green');\n\n    await api.disconnect();\n}\n\nmain().then(() => {\n    console.log('done');\n});\n")),(0,o.kt)("p",null,"4) And now, let's run it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ npx ts-node index.ts\n")),(0,o.kt)("p",null,"And you should see something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"Contract deployed at: 5Cc95McifGEqPsc9kfBNvWgAkDZeZ2BkQ5BCBXkHXmsNYavM\n Total supply before transfer: 10000\n Balance of Alice before transfer: 10000\nTransfer event received: {\n  from: null,\n  to: '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY',\n  value: ReturnNumber { rawNumber: <BN: 2710> }\n}\nTransfer event received: {\n  from: '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY',\n  to: '5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty',\n  value: ReturnNumber { rawNumber: <BN: 1> }\n}\n Total supply after transfer: 10000\n Balance of Alice after transfer: 9999\ndone\n")),(0,o.kt)("p",null,"Wow, we have successfully subscribed to events and got them!"),(0,o.kt)("h2",{id:"how-to-use-it-directly-via-typechain-polkadot"},"How to use it directly via ",(0,o.kt)("inlineCode",{parentName:"h2"},"typechain-polkadot"),"?"),(0,o.kt)("p",null,"Let's use previous example, but instead of using ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain-compiler"),", we will use ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain-polkadot")," directly."),(0,o.kt)("p",null,"1) We need to compile our contracts:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"cd ./contracts/psp22\ncargo contract build\ncd ../flipper\ncargo contract build\n")),(0,o.kt)("p",null,"2) And now, let's install ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain-polkadot"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ npm install @727-ventures/typechain-polkadot\n")),(0,o.kt)("p",null,"3) Let's create a directory with artifacts:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ mkdir artifacts\n")),(0,o.kt)("p",null,"4) And now, let's copy our artifacts to the ",(0,o.kt)("inlineCode",{parentName:"p"},"artifacts")," directory:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ cp ./contracts/psp22/target/ink/psp22.contract artifacts\n$ cp ./contracts/flipper/target/ink/flipper.contract artifacts\n")),(0,o.kt)("p",null,"And metadata, but you should rename ",(0,o.kt)("inlineCode",{parentName:"p"},"metadata.json")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"<contract-name>.json"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ cp ./contracts/flipper/target/ink/metadata.json artifacts/flipper.json\n$ cp ./contracts/psp22/target/ink/metadata.json artifacts/psp22.json\n")),(0,o.kt)("p",null,"5) Let's run ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain-polkadot"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ npx @727-ventures/typechain-polkadot --in ./artifacts --out ./typechain-generated\n")),(0,o.kt)("p",null,"Wow! We've just generated code for our contracts using typechain directly! \ud83c\udf89"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"For more information about ",(0,o.kt)("inlineCode",{parentName:"p"},"typechain-polkadot")," you can check ",(0,o.kt)("a",{parentName:"p",href:"/docs/Typechain/typechain-polkadot/overview"},"typechain-polkadot documentation"))))}d.isMDXComponent=!0}}]);